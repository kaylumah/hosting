<p>For dotnet developers Microsoft created a dev-time convenience to handle secret values.
No need for a shared infrastructure dependency, and no need for storing secrets in the repository.
Add a helper script on top of it, and your dev shop will have a convenient way to get up and running.</p>
<p>UserSecrets are stored in an unencrypted JSON file. Depending on platform they are in either <code>%APPDATA%\Microsoft\UserSecrets</code> or <code>~/.microsoft/usersecrets</code>.</p>
<h2 id="simple-variant"><a href="#simple-variant">Simple Variant</a></h2>
<p>The simplest variant is demonstrated by this PowerShell script.
Please note, in a real-world scenario you would parameterize the script to allow entry of the secrets.
For simplicity we use random GUIDs here.</p>
<pre><code class="language-powershell">#Requires -Version 7.4

$ErrorActionPreference = &quot;Stop&quot;
$RepoRoot = Split-Path $PSScriptRoot -Parent

$Secret1 = [System.Guid]::NewGuid().ToString()
$Secret2 = [System.Guid]::NewGuid().ToString()

$APP1_FOLDER = Join-Path -Path $RepoRoot -ChildPath &quot;src/App1&quot;
Push-Location $APP1_FOLDER
Write-Host &quot;Setting secrets for $APP1_FOLDER&quot;
dotnet user-secrets clear
dotnet user-secrets set &quot;App1:ConnectionStrings:Secret1&quot; $Secret1
dotnet user-secrets set &quot;App1:ConnectionStrings:Secret2&quot; $Secret2
Pop-Location
</code></pre>
<p>This produces one of two possible outputs.</p>
<p>Failure output:</p>
<pre><code class="language-output">Could not find the global property 'UserSecretsId' in MSBuild project '/Secrets/src/App1/App1.csproj'. Ensure this property is set in the project or use the '--id' command line option.
</code></pre>
<p>Success output:</p>
<pre><code class="language-output">Setting secrets for /ExamplePath/Dev/BlogTopics/_posts/Secrets/src/App1
Successfully saved App1:ConnectionStrings:Secret1 to the secret store.
Successfully saved App1:ConnectionStrings:Secret2 to the secret store.
</code></pre>
<p>To be able to set secrets on a project level, the property UserSecretsId needs to be set.
For example <code>&lt;UserSecretsId&gt;[ANY-STRING-VALUE]&lt;/UserSecretsId&gt;</code>.
Doing this for a large solution, project-by-project can be a hassle. So I prefer creating a Directory.Build.Targets file.
We can then ensure each project either has an explicit or implicit secret id.</p>
<pre><code class="language-xml">&lt;Project&gt;
  &lt;PropertyGroup&gt;
      &lt;UserSecretsId Condition=&quot;'$(UserSecretsId)' == ''&quot;&gt;$(MSBuildProjectName)-dev-secrets&lt;/UserSecretsId&gt;
  &lt;/PropertyGroup&gt;
&lt;/Project&gt;
</code></pre>
<h2 id="multiple-secrets-at-once"><a href="#multiple-secrets-at-once">Multiple secrets at once</a></h2>
<p>The first version of the script works, but calling a command line for a ton of secrets feels ineffective.
Luckily, we can also bulk import by using a JSON file.
The trick here is to create the object in PowerShell, convert it to JSON and run the <code>dotnet user-secrets </code> command.</p>
<pre><code>#Requires -Version 7.4

$ErrorActionPreference = &quot;Stop&quot;
$RepoRoot = Split-Path $PSScriptRoot -Parent

$Secret1 = [System.Guid]::NewGuid().ToString()
$Secret2 = [System.Guid]::NewGuid().ToString()

$APP1_FOLDER = Join-Path -Path $RepoRoot -ChildPath &quot;src/App1&quot;
Push-Location $APP1_FOLDER
Write-Host &quot;Setting secrets for $APP1_FOLDER&quot;
dotnet user-secrets clear
$App1Config = @{
    App1 = @{
        ConnectionStrings = @{
            Secret1 = $Secret1
            Secret2 = $Secret2
        }
    }
}
$App1Config | ConvertTo-Json -Depth 5 | dotnet user-secrets set
Pop-Location
</code></pre>
<h2 id="multiple-project-same-secret"><a href="#multiple-project-same-secret">Multiple project same secret</a></h2>
<p>The previous iteration was already an improvement over our first script.
But, for me it does not quite match the real-world. For instance, in Azure, I would create a KeyVault per resource group. I would not create multiple key vaults. For this, I picked up the habit of prefixing secrets per executable. For example, thus far in this blog I have used <code>App1</code>.</p>
<p>If we now set the MSBuild property <code>&lt;UserSecretsId&gt;Project-5ea2d981-14f7-4487-93c0-d4b7e3dbebf1&lt;/UserSecretsId&gt;</code>, we can apply it to all projects at once.</p>
<pre><code class="language-powershell">#Requires -Version 7.4

$ErrorActionPreference = &quot;Stop&quot;

$Secret1 = [System.Guid]::NewGuid().ToString()
$Secret2 = [System.Guid]::NewGuid().ToString()


$App1Config = @{
    ConnectionStrings = @{
            Secret1 = $Secret1
            Secret2 = $Secret2
    }
}

$Config = @{
    App1 = $App1Config
}

$SecretId = &quot;Project-5ea2d981-14f7-4487-93c0-d4b7e3dbebf1&quot;
dotnet user-secrets clear --id $SecretId
$Config | ConvertTo-Json -Depth 10 | dotnet user-secrets set --id $SecretId
</code></pre>
<h2 id="closing-thoughts"><a href="#closing-thoughts">Closing thoughts</a></h2>
<p>User Secrets is a nice addition to the tool belt. Remembering the correct format of clearing/updating secrets, is not something you should burden your team with. Wrapping it inside a script for convenience is my recommended approach.
Depending on your deployment model I would go with either option 2 or option 3, keeping it as close to production as possible.</p>
<h2 id="references"><a href="#references">References</a></h2>
<ul>
<li><a href="https://learn.microsoft.com/en-us/aspnet/core/security/app-secrets" class="external">UserSecrets Documentation</a></li>
</ul>