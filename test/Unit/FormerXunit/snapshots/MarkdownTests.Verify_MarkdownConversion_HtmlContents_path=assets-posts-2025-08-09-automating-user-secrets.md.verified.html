<p>For dotnet developers Microsoft created a dev-time convenience to handle secret values.
No need for a shared infrastructure dependency, and no need for storing secrets in the repository.
Add a helper script on top of it, and your dev shop will have a convenient way to get up and running.</p>
<p>UserSecrets are stored (unencrypted) in <code>%APPDATA%\Microsoft\UserSecrets</code> or in <code>~/.microsoft/usersecrets</code>.
They follow the pattern of <code>&lt;secretid&gt;.json</code>.</p>
<h2 id="simple-variant"><a href="#simple-variant">Simple Variant</a></h2>
<p>The most similar variant is demonstrated by this PowerShell script.
Please note, in real-world scenario we would parameterize the script to allow entry of the secrets.
For simplicity we use random GUIDs here.</p>
<pre><code class="language-ps">#Requires -Version 7.4

$ErrorActionPreference = &quot;Stop&quot;
$RepoRoot = Split-Path $PSScriptRoot -Parent

$Secret1 = [System.Guid]::NewGuid().ToString()
$Secret2 = [System.Guid]::NewGuid().ToString()

$APP1_FOLDER = Join-Path -Path $RepoRoot -ChildPath &quot;src/App1&quot;
Push-Location $APP1_FOLDER
Write-Host &quot;Setting secrets for $APP1_FOLDER&quot;
dotnet user-secrets clear
dotnet user-secrets set &quot;App1:ConnectionStrings:Secret1&quot; $Secret1
dotnet user-secrets set &quot;App1:ConnectionStrings:Secret2&quot; $Secret2
Pop-Location
</code></pre>
<p>This produces one of two possible outputs. It does not know the secret filename
For that you need <code>&lt;UserSecretsId&gt;[ANY-STRING-VALUE]&lt;/UserSecretsId&gt;</code> to be present.</p>
<p>Personally I prefer setting it like this in my Directory.Build.Targets
The following ensures the UserSecretsId is always present for each project.
Either explicitly or with a fallback.</p>
<pre><code class="language-xml">&lt;Project&gt;
  &lt;PropertyGroup&gt;
      &lt;UserSecretsId Condition=&quot;'$(UserSecretsId)' == ''&quot;&gt;$(MSBuildProjectName)-dev-secrets&lt;/UserSecretsId&gt;
  &lt;/PropertyGroup&gt;
&lt;/Project&gt;
</code></pre>
<p>Failure output:</p>
<pre><code class="language-output">Could not find the global property 'UserSecretsId' in MSBuild project '/Secrets/src/App1/App1.csproj'. Ensure this property is set in the project or use the '--id' command line option.
</code></pre>
<p>Success output:</p>
<pre><code class="language-output">Setting secrets for /ExamplePath/Dev/BlogTopics/_posts/Secrets/src/App1
Successfully saved App1:ConnectionStrings:Secret1 to the secret store.
Successfully saved App1:ConnectionStrings:Secret2 to the secret store.
</code></pre>
<h2 id="multiple-secrets-at-once"><a href="#multiple-secrets-at-once">Multiple secrets at once</a></h2>
<p>Instead of doing secret by secret, project by project, we can also store secrets in bulk.
By constructing an object and converting it to JSON we simplify the steps a lot.</p>
<pre><code>#Requires -Version 7.4

$ErrorActionPreference = &quot;Stop&quot;
$RepoRoot = Split-Path $PSScriptRoot -Parent

$Secret1 = [System.Guid]::NewGuid().ToString()
$Secret2 = [System.Guid]::NewGuid().ToString()

$APP1_FOLDER = Join-Path -Path $RepoRoot -ChildPath &quot;src/App1&quot;
Push-Location $APP1_FOLDER
Write-Host &quot;Setting secrets for $APP1_FOLDER&quot;
dotnet user-secrets clear
$App1Config = @{
    App1 = @{
        ConnectionStrings = @{
            Secret1 = $Secret1
            Secret2 = $Secret2
        }
    }
}
$App1Config | ConvertTo-Json -Depth 5 | dotnet user-secrets set
Pop-Location
</code></pre>
<h2 id="multiple-project-same-secret"><a href="#multiple-project-same-secret">Multiple project same secret</a></h2>
<p>In Azure, I usually have a simple KeyVault instance per resource group, and not a KeyVault per executable.
That's why I picked up the habit of prefixing / scoping secrets.
In this case I have been prefixing them with <code>App1</code>.</p>
<p>Instead of setting secrets per project, we can also have a shared secret-id for a solution.
This would mimic the behavior when deployed for production.</p>
<pre><code class="language-ps">#Requires -Version 7.4

$ErrorActionPreference = &quot;Stop&quot;

$Secret1 = [System.Guid]::NewGuid().ToString()
$Secret2 = [System.Guid]::NewGuid().ToString()


$App1Config = @{
    ConnectionStrings = @{
            Secret1 = $Secret1
            Secret2 = $Secret2
    }
}

$Config = @{
    App1 = $App1Config
}

$SecretId = &quot;Project-5ea2d981-14f7-4487-93c0-d4b7e3dbebf1&quot;
dotnet user-secrets clear --id $SecretId
$Config | ConvertTo-Json -Depth 10 | dotnet user-secrets set --id $SecretId
</code></pre>
<h2 id="closing-thoughts"><a href="#closing-thoughts">Closing thoughts</a></h2>
<p>This concludes my post.
TODO..</p>
<h2 id="references"><a href="#references">References</a></h2>
<ul>
<li><a href="https://learn.microsoft.com/en-us/aspnet/core/security/app-secrets" class="external">UserSecrets Documentation</a></li>
</ul>