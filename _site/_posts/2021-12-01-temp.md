---
title: "-"
description: "-"
cover_image: '/assets/images/posts/20211114/capture-logs-in-unit-tests/cover_image.png'
image: '/assets/images/posts/20211114/capture-logs-in-unit-tests/cover_image.png'
tags:
  - "csharp"
  - "configuration"
# comment_id: '50'
# publishedtime: '20:30'
---
Almost every project will have some settings that are configured differently per environment. Chapter three of "The Twelve-Factor App" [explains](https://12factor.net/config) why separating configuration from code is a good idea. In `.NET`, we use the `IConfigurationManager` to manage our configuration. An `IOptions<>` is used to make a configuration available as a strongly-typed type in our applications.

As I understand it, the configuration concept in `.NET` is the combination of different configuration sources, called configuration providers, resulting in a single combined configuration. In contrast, the `options` concept provides access to `configuration` from our application code. I've attempted to illustrate it with the image below. 

![IMAGE 1](/_site/assets/images/posts/20211128/temp/001_configuration_sources.svg)

## Configuration in .NET

Technically the image above is an over-simplification. In reality, you use an `IConfigurationBuilder` where different providers are provided, and the configuration block in the middle is the merged build-result of the configuration builder. In fact, you get a preconfigured configuration builder every time you use the `ASP.NET` Web templates. You get a [default HostBuilder](https://github.com/dotnet/runtime/blob/12a8819eee9865eb38bca6c05fdece1053102854/src/libraries/Microsoft.Extensions.Hosting/src/Host.cs#L53) that setups an [IHost](https://github.com/dotnet/runtime/blob/12a8819eee9865eb38bca6c05fdece1053102854/src/libraries/Microsoft.Extensions.Hosting/src/HostBuilder.cs#L124). This default builder also takes care of the [default configuration](https://github.com/dotnet/runtime/blob/12a8819eee9865eb38bca6c05fdece1053102854/src/libraries/Microsoft.Extensions.Hosting/src/HostingHostBuilderExtensions.cs#L188).

The default configuration adds in order
- appsettings.json
- appsettings.Environment.json
- user secrets (if the environment is development)
- environment variables
- command-line arguments

The priority of settings is in the reverse order of adding them to the builder. Passing a setting via the `command line` will always win from a setting in the `appsettings.json` file. Fun fact, there are two configurations in `ASP.NET`. You have the `AppConfiguration` we just discussed, and you have the `HostConfiguration`. The `HostConfiguration` is used to set variables like the `DOTNET_ENVIRONMENT`, which is used to load the proper `appsettings.json` and user secrets. Via means of `ChainedConfiguration` the entire `HostConfiguration` is also available as part of `AppConfiguration`.

Let's look at an example. Take the following JSON configuration:

```json
{
    "MySample": {
        "MyText": "Hello World!",
        "MyCollection": [
            {
                "MyOtherText": "Goodbye Cruel World!"
            }
        ]
    }
}
```

That would result in the following two settings being present in our IConfiguration.
- `MySample:MyText`
- `MySample:MyCollection:0:MyOtherText`

With this bit of knowledge, you can override any setting in any provider you can imagine. Visually it would look something like the image below. You can provide sensible defaults in appsettings.json and overwrite values as needed.

![IMAGE 2](/_site/assets/images/posts/20211128/temp/002_configuration_dotnet.svg)

>  As pointed out by the "The Twelve-Factor App" article linked previously, adding configuration files per environment does not scale. I typically end up with one appsettings.json for the defaults and an appsettings.Production.json that gets transformed in my CICD pipeline.

You can [read about changes to IConfiguration](https://andrewlock.net/exploring-dotnet-6-part-1-looking-inside-configurationmanager-in-dotnet-6/) in `.NET6` in a post from Andrew Lock. It also contains a different visual representation of configuration, which neatly displays the merging of the different levels.

## Options in .NET

According to the [Microsoft Docs](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration/options?view=aspnetcore-6.0#bind-hierarchical-configuration) the options pattern is the preferred way to read related configuration values. The options pattern comes in three different flavours, `IOptions<>`, `IOptionsSnapshot<>` and `IOptionsMonitor<>`. Probably the most used one is the default `IOptions` one, with the drawback that you cannot read configuration after your app starts. Others have taken the task upon themself to explain the differences between the interfaces, for example [Andrew Lock](https://andrewlock.net/creating-singleton-named-options-with-ioptionsmonitor) and [Khalid Abuhakmeh](https://khalidabuhakmeh.com/aspnet-core-ioptions-configuration). For this post, I will keep it simple with the regular IOptions.

A typical registration of configuration would look like this:

```csharp
public static partial class ServiceCollectionExtensions
{
    public static IServiceCollection AddDemo(this IServiceCollection services, IConfiguration configuration)
    {
        services.Configure<DemoOptions>(configuration.GetSection(DemoOptions.DefaultConfigurationSectionName));
        return services;
    }
}
```

> This snippet requires the `Microsoft.Extensions.Options.ConfigurationExtensions` package to work

Looking at our dependency injection container right after this registration, we see more than just IOptions. We have a total of seven registrations at this point.

```output
ServiceType = 'Microsoft.Extensions.Options.IOptions`1[TOptions]' ImplementationType = 'Microsoft.Extensions.Options.UnnamedOptionsManager`1[TOptions]'
ServiceType = 'Microsoft.Extensions.Options.IOptionsSnapshot`1[TOptions]' ImplementationType = 'Microsoft.Extensions.Options.OptionsManager`1[TOptions]'
ServiceType = 'Microsoft.Extensions.Options.IOptionsMonitor`1[TOptions]' ImplementationType = 'Microsoft.Extensions.Options.OptionsMonitor`1[TOptions]'
ServiceType = 'Microsoft.Extensions.Options.IOptionsFactory`1[TOptions]' ImplementationType = 'Microsoft.Extensions.Options.OptionsFactory`1[TOptions]'
ServiceType = 'Microsoft.Extensions.Options.IOptionsMonitorCache`1[TOptions]' ImplementationType = 'Microsoft.Extensions.Options.OptionsCache`1[TOptions]'
ServiceType = 'Microsoft.Extensions.Options.IOptionsChangeTokenSource`1[Test.Unit.DemoOptions]' ImplementationType = ''
ServiceType = 'Microsoft.Extensions.Options.IConfigureOptions`1[Test.Unit.DemoOptions]' ImplementationType = ''
```

The problem with the above approach is that it assumes the configuration exists at a predefined section, which is not very flexible. An alternative approach to register `IOptions` is the use of an `Action<>`.

```csharp
public static partial class ServiceCollectionExtensions
{
    public static IServiceCollection AddExample(this IServiceCollection services, Action<ExampleOptions> configureDelegate)
    {
        services.Configure(configureDelegate);
        return services;
    }
}
```

With this approach, we get a total of six DI registrations.

```output
ServiceType = 'Microsoft.Extensions.Options.IOptions`1[TOptions]' ImplementationType = 'Microsoft.Extensions.Options.UnnamedOptionsManager`1[TOptions]'
ServiceType = 'Microsoft.Extensions.Options.IOptionsSnapshot`1[TOptions]' ImplementationType = 'Microsoft.Extensions.Options.OptionsManager`1[TOptions]'
ServiceType = 'Microsoft.Extensions.Options.IOptionsMonitor`1[TOptions]' ImplementationType = 'Microsoft.Extensions.Options.OptionsMonitor`1[TOptions]'
ServiceType = 'Microsoft.Extensions.Options.IOptionsFactory`1[TOptions]' ImplementationType = 'Microsoft.Extensions.Options.OptionsFactory`1[TOptions]'
ServiceType = 'Microsoft.Extensions.Options.IOptionsMonitorCache`1[TOptions]' ImplementationType = 'Microsoft.Extensions.Options.OptionsCache`1[TOptions]'
ServiceType = 'Microsoft.Extensions.Options.IConfigureOptions`1[Test.Unit.ExampleOptions]' ImplementationType = ''
```

The only difference is that we do not get the `IOptionsChangeTokenSource`. To be most flexible, you can combine both techniques like this.

```csharp
public static partial class ServiceCollectionExtensions
{
    public static IServiceCollection AddExample(this IServiceCollection services, IConfiguration config)
    {
        services.AddExample(options => config.GetSection(ExampleOptions.DefaultConfigurationSectionName).Bind(options));
        return services;
    }

    public static IServiceCollection AddExample(this IServiceCollection services, Action<ExampleOptions> configureDelegate)
    {
        services.Configure(configureDelegate);
        return services;
    }
}
```

## Validated Options

Now that we covered the basics, I can move on to the focal point of this blog post. As you can imagine overlaying the different configuration sources does not guarantee a valid result from the point of view of your application. Worse, since the number of configuration sources can differ between environments, you can potentially have configuration issues very late in your CICD pipeline. For example, if you use Azure Key Vault as a configuration provider, settings might be changed by anyone with access to the vault.

In my article [Generate C# client for OpenAPI](https://kaylumah.nl/2021/05/23/generate-csharp-client-for-openapi.html), I used HttpClient to call a generated service. HTTP is the perfect example for validating configuration. In our API example, we will likely have different base URLs per environment. If we represent an URL as a string in configuration, it is feasible to enter "not-an-url" as its value, which causes your application to crash and burn in production.

### Missing Configuration Sections

### DataAnnotations Validation