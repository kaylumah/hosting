---
title: "-"
description: "-"
cover_image: '/assets/images/posts/20211114/capture-logs-in-unit-tests/cover_image.png'
image: '/assets/images/posts/20211114/capture-logs-in-unit-tests/cover_image.png'
# tags:
#   - "csharp"
#   - "testing"
#   - "xunit"
# comment_id: '50'
# publishedtime: '20:30'
---
Almost every project will have some settings that are configured differently per environment. Chapter three of "The Twelve-Factor App" [explains](https://12factor.net/config) why separating configuration from code is a good idea. In `.NET`, we use the `IConfigurationManager` to manage our configuration. An `IOptions<>` is used to make a configuration available as a strongly-typed type in our applications.

As I understand it, the configuration concept in `.NET` is the combination of different configuration sources, called configuration providers, resulting in a single combined configuration. In contrast, the `options` concept provides access to `configuration` from our application code. I've attempted to illustrate it with the image below. 

![IMAGE 1](/_site/assets/images/posts/20211128/temp/001_configuration_sources.svg)

## Configuration in .NET

Technically the image above is an over-simplification. In reality, you use an `IConfigurationBuilder` where different providers are provided, and the configuration block in the middle is the merged build-result of the configuration builder. In fact, you get a preconfigured configuration builder every time you use the `ASP.NET` Web templates. You get a [default HostBuilder](https://github.com/dotnet/runtime/blob/12a8819eee9865eb38bca6c05fdece1053102854/src/libraries/Microsoft.Extensions.Hosting/src/Host.cs#L53) that setups an [IHost](https://github.com/dotnet/runtime/blob/12a8819eee9865eb38bca6c05fdece1053102854/src/libraries/Microsoft.Extensions.Hosting/src/HostBuilder.cs#L124). This default builder also takes care of the [default configuration](https://github.com/dotnet/runtime/blob/12a8819eee9865eb38bca6c05fdece1053102854/src/libraries/Microsoft.Extensions.Hosting/src/HostingHostBuilderExtensions.cs#L188).

The default configuration adds in order
- appsettings.json
- appsettings.Environment.json
- user secrets (if the environment is development)
- environment variables
- command-line arguments

The priority of settings is in the reverse order of adding them to the builder. Passing a setting via the `command line` will always win from a setting in the `appsettings.json` file. Fun fact, there are two configurations in `ASP.NET`. You have the `AppConfiguration` we just discussed, and you have the `HostConfiguration`. The `HostConfiguration` is used to set variables like the `DOTNET_ENVIRONMENT`, which is used to load the proper `appsettings.json` and user secrets. Via means of `ChainedConfiguration` the entire `HostConfiguration` is also available as part of `AppConfiguration`.

Let's look at an example. Take the following JSON configuration:

```json
{
    "MySample": {
        "MyText": "Hello World!",
        "MyCollection": [
            {
                "MyOtherText": "Goodbye Cruel World!"
            }
        ]
    }
}
```

That would result in the following two settings being present in our IConfiguration.
- `MySample:MyText`
- `MySample:MyCollection:0:MyOtherText`

With this bit of knowledge, you can override any setting in any provider you can imagine. Visually it would look something like the image below. You can provide sensible defaults in appsettings.json and overwrite values as needed.

![IMAGE 2](/_site/assets/images/posts/20211128/temp/002_configuration_dotnet.svg)

>  As pointed out by the "The Twelve-Factor App" article linked previously, adding configuration files per environment does not scale. I typically end up with one appsettings.json for the defaults and an appsettings.Production.json that gets transformed in my CICD pipeline.