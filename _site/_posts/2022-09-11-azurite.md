---
---
## How to test a dependency on Azure?

A recent project tasked me with integrating an application with Azure Blob Storage. Due to my post "Working with Azure SDK for .NET", I knew all about the current SDK to interface with Azure. The team in charge of the dotnet SDK has done a great job with providing accessible samples. My previous post did not focus on the testability aspects of the system, mainly because it was a simple demo for production code that is, of course, a no-go.

There are a few ways we can go about testing this:
1. Create a mock or fake implementation of every Storage API required.
2. Hide the blob implementation behind an internal interface and mock that in your tests.
3. Create a real storage account (per developer) in Azure.
4. Emulate storage account.

The argument to go with option 1 / 2 is that you, the developer, are not responsible for testings Azure's internal components. Option 3 has the challenge of cost and test repeatability. Because option three hosts the dependency externally, you need to set up and teardown for anything done in your tests. For example, you cannot create a file with the same name twice. Option 4 has the problem: any emulator does not guarantee to be 100% equal to the real deal.

While I agree with the argument for the first two options, the point here is to test if we can successfully integrate with Azure (as opposed to asserting their SDK works as expected). You can debate if testing with emulators or Azure is still a unit test. I think using EntityFramework's DbContext in a test would warrant the same definition question.

> **Important**: if you only remember one thing from this post, let it be that every option except the third requires you to test in Azure. All other options are not the actual integration, and your application can behave differently once deployed.

## How can Azurite help by emulating Azure Storage?

The test solution I picked was using the popular open-source emulator called [Azurite](https://docs.microsoft.com/en-us/azure/storage/common/storage-use-azurite). The Azurite tool offers a local environment for Azure Blob, Azure Queue and Azure Table services. In the past, we also had Microsofts own Storage Account Emulator, but it appears that development on that has stopped, and the focussed shifted to Azurite.

There are several ways to run Azurite (i.e. Docker or NPM). 

```shell
# install Azurite
npm install -g azurite

# run Azurite
azurite --silent --location c:\azurite --debug c:\azurite\debug.log
```

If we create a demo app and install blob storage via `dotnet add package Azure.Storage.Blobs`. We can connect with the following snippet:

```csharp
using Azure.Storage.Blobs;

var connectionString = "DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://127.0.0.1:10000/devstoreaccount1;QueueEndpoint=http://127.0.0.1:10001/devstoreaccount1;TableEndpoint=http://127.0.0.1:10002/devstoreaccount1;";
var blobServiceClient = new BlobServiceClient(connectionString);
var properties = await blobServiceClient.GetPropertiesAsync().ConfigureAwait(false);
```

The snippet works because the connection string we provided is the default connection string for Azurite. It contains the default account known as `devstoreaccount1` and connects over HTTP. The default connection string also assumes you are running blob, queue and table services. For example, on NPM you could run:

```shell
# Run only Blob
azurite-blob --silent --location c:\azurite --debug c:\azurite\debug.log
# Run only Queue
azurite-queue --silent --location c:\azurite --debug c:\azurite\debug.log
# Run only Table
azurite-table --silent --location c:\azurite --debug c:\azurite\debug.log
```